 1）对于==，如果作用于基本数据类型的变量，则直接比较其存储的 “值”是否相等；

　　　　如果作用于引用类型的变量，则比较的是所指向的对象的地址

　　2）对于equals方法，注意：equals方法不能作用于基本数据类型的变量

　　　　如果没有对equals方法进行重写，则比较的是引用类型的变量所指向的对象的地址；

　　　　诸如String、Date等类对equals方法进行了重写的话，比较的是所指向的对象的内容。
2.equals()

 　　equals是根类Obeject中的方法。源代码如下：

public boolean equals(Object obj) {
    return (this == obj);
}
　　可见默认的equals方法，直接调用==，比较对象地址。

 　 不同的子类，可以重写此方法，进行两个对象的equals的判断。

　　String类源码中重写的equals方法如下
public boolean equals(Object anObject) {
 2         if (this == anObject) {
 3             return true;
 4         }
 5         if (anObject instanceof String) {
 6             String anotherString = (String) anObject;
 7             int n = value.length;
 8             if (n == anotherString.value.length) {
 9                 char v1[] = value;
10                 char v2[] = anotherString.value;
11                 int i = 0;
12                 while (n-- != 0) {
13                     if (v1[i] != v2[i])
14                             return false;
15                     i++;
16                 }
17                 return true;
18             }
19         }
20         return false;
21     }
从上面的代码中可以看到，

　　(1)String类中的equals首先比较地址，如果是同一个对象的引用，可知对象相等，返回true。

　　(2)若果不是同一个对象，equals方法挨个比较两个字符串对象内的字符，只有完全相等才返回true，否则返回false。

一、java当中的数据类型和“==”的含义：

基本数据类型（也称原始数据类型） ：byte,short,char,int,long,float,double,boolean。他们之间的比较，应用双等号（==）,比较的是他们的值。
引用数据类型：当他们用（==）进行比较的时候，比较的是他们在内存中的存放地址（确切的说，是堆内存地址）。
注：对于第二种类型，除非是同一个new出来的对象，他们的比较后的结果为true，否则比较后结果为false。因为每new一次，都会重新开辟堆内存空间。

二、equals()方法介绍：

JAVA当中所有的类都是继承于Object这个超类的，在Object类中定义了一个equals的方法，equals的源码是这样写的：

public boolean equals(Object obj) {
    //this - s1
    //obj - s2
    return (this == obj);
}
可以看到，这个方法的初始默认行为是比较对象的内存地址值，一般来说，意义不大。所以，在一些类库当中这个方法被重写了，如String、Integer、Date。在这些类当中equals有其自身的实现（一般都是用来比较对象的成员变量值是否相同），而不再是比较类在堆内存中的存放地址了。 
所以说，对于复合数据类型之间进行equals比较，在没有覆写equals方法的情况下，他们之间的比较还是内存中的存放位置的地址值，跟双等号（==）的结果相同；如果被复写，按照复写的要求来。

我们对上面的两段内容做个总结吧：

 == 的作用：
　　基本类型：比较的就是值是否相同
　　引用类型：比较的就是地址值是否相同
equals 的作用:
　　引用类型：默认情况下，比较的是地址值。
注：不过，我们可以根据情况自己重写该方法。一般重写都是自动生成，比较对象的成员变量值是否相同


如果一个变量指向的数据是对象类型的，那么，这时候涉及了两块内存，对象本身占用一块内存（堆内存），变量也占用一块内存，例如Objet obj = newObject();变量obj是一个内存，new Object()是另一个内存，此时，变量obj所对应的内存中存储的数值就是对象占用的那块内存的首地址。对于指向对象类型的变量，如果要比较两个变量是否指向同一个对象，即要看这两个变量所对应的内存中的数值是否相等，这时候就需要用==操作符进行比较。
String a = new String("abc");
String b = new String("abc");
a == b; // false
a.equlas(b); // true

Person a = new Person ("abc");
Person b = new Person ("abc");
a == b; // false
a.equlas(b); // false


String a = "a1";
String b = "b1";
String ab = "a1b1";
a+b == ab; // false
(a+b).equals(b); // true



静态：static

用法：是一个修饰符，用于修饰成员（成员变量，成员函数），

　　当成员被静态修饰后，就多了一个调用方式，除了可以被对象调用外，还可以直接被类名调：类名.静态成员

　　　　类名.静态成员

存在：方法区，共享区，数据区（非堆内存、栈内存的另一个存储区），Static 块仅在该类被加载时执行一次。

　

static特点：

1，随着类的加载而加载，也就是说静态会随着类的消失而消失，说明他的生命周期最长

2，优先于对象的存在。（静态先存在，对象后存在。）

3，被所有对象所共享

4，可以直接被类名调用

　　由于静态static不依赖于任何对象就可以进行访问，因此对于静态来说，是没有this的，因为它不依附于任何对象，既然都没有对象，就谈不上this了。并且由于这个特性，在静态方法中不能访问类的非静态成员变量和非静态成员方法，因为非静态成员方法/变量都是必须依赖具体的对象才能够被调用。

　　内部类中不能存在static修饰的成员，因为static随着类加载产生，内部类依附于宿主类，系统加载：宿主类-->静态-->内部类，而内部类的静态是随着内部类加载产生，与加载类就加载static矛盾，所以内部类中不能存在static修饰

实例变量和类变量的区别：
1，存放位置。
　　类变量随着类的加载而存在于方法区中。
　　实例变量随着对象的建立而存在于堆内存中。
2，生命周期：
　　类变量生命周期最长，随着类的消失而消失。
　　实例变量生命周期随着对象的消失而消失。

静态使用注意事项：

1，静态方法只能访问静态成员，非静态方法既可以访问静态也可以访问非静态。（Java虚拟机（JVM）加载类时，就会执行该static，静态优先于其他产生对象产生）。

2，静态方法中不可定义this，super等关键字：

　　　　（this:this代表当前对象，static于类加载的时候存在优先于实例对象的产生，static调用非静态时并未产生对象，所以this不代表任何对象为null,未进行初始化操作。）

3，主函数是静态方法。 

静态有利有弊：

利：对对象的共享数据进行单独空间的存储，节省空间，没有必要每一格对象中都存储一份。可以直接被类名调用。

弊：生命周期过长，访问出现局限性（静态虽好，只能访问静态） 

 

static和final一块用表示什么 
1，static final用来修饰成员变量和成员方法，可简单理解为"全局常量"
2，对于变量，表示一旦给值就不可修改，并且通过类名可以访问。 
3，对于方法，表示不可覆盖，并且可以通过类名直接访问。

类成员变量：

static修饰:静态变量或类变量

无static修饰：实例变量

　　静态变量在内存中只有一个拷贝（节省内存），JVM只为静态分配一次内存（方法区，共享区，数据区），在加载类的过程中完成静态变量的内存分配，可用类名.成员，当然也可以通过对象来访问（但是这是不推荐的，对象产生新的开辟内存空间，static优先于对象的产生，节省内存）。 

　　不能直接访问所属类的实例变量和实例方法

　　static方法独立于任何实例，因此static方法必须被实现，而不能是抽象的abstract。

什么时候使用静态：

　　因为静态修饰的内容有成员变量和函数。

　　使用静态变量（类变量）：当对象中出现共享数据时，该数据被静态所修饰。对象中的特有数据要定义成非静态存在于堆内存中。

　　使用静态函数：当功能内部没有访问到非静态数据(对象的特有数据)，那么该功能可以定义成静态的。

静态代码块。
　　格式：
　　　　static{
　　　　　　　　静态代码块中的执行语句。
　　　　　　}

　　特点：随着类的加载而执行，只执行一次,并优先于主函数。用于给类进行初始化的。


1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
class StaticCode
　　{
    int num = 9;
    StaticCode()
    {
        System.out.println("b");
    }
 
    static
    {
            //只执行一次,并优先于主函数。
     
        System.out.println("a");
    }
    {
        System.out.println("c"+this.num);
    }
 
    StaticCode(int x)
    {
        System.out.println("d");
    }
    public static void show()
    {
        System.out.println("show run");
    }
}
 
class StaticCodeDemo
　　{
    static
    {
        System.out.println("b");//（1）
    }
    public static void main(String[] args)
    {
     
            //尽管new StaticCode两次，但是静态代码块只执行一次
     （1）new StaticCode();
         new StaticCode();
         System.out.println("over");   //b c a over    
                //构造代码块优先于对象产生
                //优先级：静态代码库>代码块>对象产生
      （2）new StaticCode(4);//b c a c9 d
        //StaticCode.show();//b c a  show run c9
            (3)当构造代码对象为空时，没有任何意义，未使用该类，所以哪怕是静态成员也不存在
        //StaticCode s = null;
           （4）
        //s = new StaticCode();//b c a  c9 b
 
 
    }
    static
    {
        System.out.println("c");//（2）
    }
}
//d:\>java0217\day06>java StaticCodeDemo 先加载b c


3.优点和适用场景
 
1）单例模式的优点：
 
在内存中只有一个对象，节省内存空间。
避免频繁的创建销毁对象，可以提高性能。
避免对共享资源的多重占用。
可以全局访问。
2）适用场景：
 
需要频繁实例化然后销毁的对象。
创建对象时耗时过多或者耗资源过多，但又经常用到的对象。
有状态的工具类对象。
频繁访问数据库或文件的对象。
4.使用时注意事项
 
1）使用时不能用反射模式创建单例，否则会实例化一个新的对象
 
2）使用懒单例模式时注意线程安全问题
 
3）饿单例模式和懒单例模式构造方法都是私有的，因而是不能被继承的，有些单例模式可以被继承（如登记式模式）

    volatile是一个类型修饰符,它是被设计用来修饰被不同线程访问和修改的变量,被volatile类型修饰的变量,系统每次用到它时都是直接从对应的内存当中读取，而不是利用缓存，在使用了volatile修饰成员变量后，所有线程 在任何时候所看到的变量都是相同的。
